// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Enums
enum Status {
  REQUESTED
  BOOKED
  AVAILABLE
  FULL
  CANCELLED
}

enum SessionType {
  INDIVIDUAL
  GROUP
}

enum ProductType {
  INDIVIDUAL_SESSION
  FULL_SEMESTER_BUNDLE
  MIDTERM_FINAL_BUNDLE
  GROUP_SESSION_PASS
}

enum BundleCoverageType {
  FULL_SEMESTER
  MIDTERM_FINAL_ONLY
}

// Models
model Student {
  id        String   @id @default(cuid())
  email     String   @unique
  password  String
  name      String
  totalCredits      Int     @default(0)
  usedCredits       Int     @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  bookings         BookingStudent[]
  bundlePurchases  BundlePurchase[]
  creditHistory    CreditTransaction[]

  @@map("students")
}

model Ta {
  id        String   @id @default(cuid())
  email     String   @unique
  password  String
  name      String
  degree    String?
  gpa       Float?
  bio       String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  bookings              Booking[]
  groupSessionTemplates GroupSessionTemplate[]
  courses               CourseTA[]
  availabilitySlots     TAAvailability[]

  @@map("tas")
}

model CreditTransaction {
  id        String   @id @default(cuid())
  studentId String
  amount    Int
  type      String   // "ADD", "DEDUCT", "REFUND"
  reason    String?
  createdAt DateTime @default(now())

  student Student @relation(fields: [studentId], references: [id], onDelete: Cascade)

  @@map("credit_transactions")
}

model TAAvailability {
  id          String   @id @default(cuid())
  taId        String
  courseId    String
  date        DateTime // Specific date for availability
  startTime   String   // HH:mm format
  endTime     String   // HH:mm format
  capacity    Int
  bookedCount Int      @default(0)
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  ta     Ta     @relation(fields: [taId], references: [id], onDelete: Cascade)
  course Course @relation(fields: [courseId], references: [id], onDelete: Cascade)

  @@unique([taId, courseId, date, startTime])
  @@map("ta_availability")
}

model Course {
  id          String  @id @default(cuid())
  code        String  @unique
  name        String
  description String?

  products              Product[]
  bookings              Booking[]
  groupSessionTemplates GroupSessionTemplate[]
  bundlePurchases       BundlePurchase[]
  tas                   CourseTA[]
  taAvailability        TAAvailability[]

  @@map("courses")
}

model CourseTA {
  courseId String
  taId     String

  course Course @relation(fields: [courseId], references: [id], onDelete: Cascade)
  ta     Ta     @relation(fields: [taId], references: [id], onDelete: Cascade)

  @@id([courseId, taId])
  @@map("course_tas")
}

model Product {
  id          String      @id @default(cuid())
  courseId    String
  name        String
  productType ProductType
  description String?
  basePrice   Decimal     @db.Decimal(10, 2)
  isActive    Boolean     @default(true)

  course           Course           @relation(fields: [courseId], references: [id], onDelete: Cascade)
  bundlePurchases  BundlePurchase[]

  @@unique([courseId, productType])
  @@map("products")
}

model BundlePurchase {
  id               String              @id @default(cuid())
  studentId        String
  courseId         String
  productId        String
  coverageType     BundleCoverageType
  totalSessions    Int
  remainingSessions Int
  validFrom        DateTime
  validTo          DateTime
  createdAt        DateTime            @default(now())
  updatedAt        DateTime            @updatedAt

  student  Student   @relation(fields: [studentId], references: [id], onDelete: Cascade)
  course   Course    @relation(fields: [courseId], references: [id], onDelete: Cascade)
  product  Product   @relation(fields: [productId], references: [id], onDelete: Cascade)
  bookings Booking[]

  @@unique([studentId, courseId, productId])
  @@map("bundle_purchases")
}

model GroupSessionTemplate {
  id             String  @id @default(cuid())
  courseId       String
  taId           String
  dayOfWeek      Int
  startTime      String
  endTime        String
  capacity       Int
  pricePerStudent Decimal @db.Decimal(10, 2)
  isActive       Boolean @default(true)

  course   Course    @relation(fields: [courseId], references: [id], onDelete: Cascade)
  ta       Ta        @relation(fields: [taId], references: [id], onDelete: Cascade)
  bookings Booking[]

  @@map("group_session_templates")
}

model Booking {
  id                    String    @id @default(cuid())
  courseId              String
  taId                  String
  status                Status
  sessionType           SessionType
  date                  DateTime
  durationMinutes       Int
  pricePerStudent       Decimal   @db.Decimal(10, 2)
  groupSessionTemplateId String?
  bundlePurchaseId      String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  course               Course                @relation(fields: [courseId], references: [id], onDelete: Cascade)
  ta                   Ta                    @relation(fields: [taId], references: [id], onDelete: Cascade)
  groupSessionTemplate GroupSessionTemplate? @relation(fields: [groupSessionTemplateId], references: [id], onDelete: SetNull)
  bundlePurchase       BundlePurchase?       @relation(fields: [bundlePurchaseId], references: [id], onDelete: SetNull)
  students             BookingStudent[]

  @@map("bookings")
}

model BookingStudent {
  bookingId String
  studentId String

  booking Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  student Student @relation(fields: [studentId], references: [id], onDelete: Cascade)

  @@id([bookingId, studentId])
  @@map("booking_students")
}
